# Hatchery Phased Execution Plan (Stability-First, Internal Alpha)

## Summary
This plan is optimized for your selected priorities:
1. `Phase 1 focus`: **Stability First**
2. `Launch target`: **Internal Alpha**

Execution strategy:
1. Phase 1 hardens security, data contracts, and quality gates so the system is safe to operate.
2. Phase 2 delivers true end-to-end activation from pitch to live runtime.
3. Phase 3 adds operator-grade interventions and observability for sustained reliability.

No implementation decisions are left open below.

## Phase Breakdown

## Phase 1 — Production Hardening Baseline (7–10 days)
Goal: eliminate current production blockers without expanding product surface area.

Scope:
1. Add access control for app and API.
2. Lock down cron and runtime control paths.
3. Fix schema/runtime contract mismatches.
4. Fix generated config/seed contract mismatches.
5. Make CLI messaging truthful for unsupported deployment paths.
6. Add enforceable CI gates (lint, typecheck, tests).

Exit criteria:
1. Unauthenticated access to protected app/API routes is blocked.
2. Cron endpoint rejects unauthorized requests.
3. `ops_action_runs` writes succeed consistently.
4. `agent_configs` consumers work with generated data shape.
5. Seed SQL generated by CLI/frontend is schema-compatible.
6. CI runs and fails on lint/type/test regressions.
7. Critical-path tests pass.

## Phase 2 — Idea-to-Active Activation Flow (7–10 days)
Goal: replace “download configs” with one-click activation to a running company.

Scope:
1. Add backend activation API from completed pitch session.
2. Add atomic activation transaction path (upsert policies, step registry, triggers, relationships, runtime control).
3. Add first mission bootstrap during activation.
4. Add Launch Readiness UI and activation progress states.
5. Add safe “replace existing runtime config” confirmation for single-tenant overwrite.

Exit criteria:
1. Completed pitch session can be activated in one flow.
2. Activation writes all required runtime artifacts atomically.
3. First mission appears and executes after activation.
4. User can see readiness checks and activation outcome in UI.

## Phase 3 — Operator Reliability Layer (7–10 days)
Goal: make runtime operable under failure, not just happy-path successful.

Scope:
1. Add intervention queue for failed/safety-blocked/escalated work.
2. Add operator actions (acknowledge, retry, reassign, resolve).
3. Add baseline observability (run IDs, failure counters, step latency, alert thresholds).
4. Add dashboard operational summary panel.

Exit criteria:
1. All unresolved runtime blockers are visible in one queue.
2. Operators can recover failed flows without direct DB edits.
3. Core health metrics are queryable and visible in UI.

---

## Phase 1 Succession Plan (Exact Execution Order)

## PR1 — Access Control + Route Protection
Implementation:
1. Add `packages/frontend/middleware.ts` with HTTP Basic Auth for `/(.*)`, `/pitch(.*)`, and `/api/(.*)` except `/api/heartbeat`.
2. Credentials source: `HATCHERY_BASIC_AUTH_USER`, `HATCHERY_BASIC_AUTH_PASS`.
3. Return `401` + `WWW-Authenticate` on missing/invalid credentials.

Acceptance:
1. Protected pages/API require credentials.
2. Browser-authenticated operator can still use dashboard and pitch flows.

## PR2 — Cron Endpoint Hardening
Implementation:
1. Restrict `GET /api/heartbeat` to `Authorization: Bearer ${CRON_SECRET}`.
2. Return `401` when header missing/invalid.
3. Keep manual run path through `/api/control` (already app-auth protected by middleware).

Acceptance:
1. Direct unauthenticated calls to `/api/heartbeat` fail.
2. Valid cron secret path succeeds.

## PR3 — Runtime Contract SQL Fixes
Implementation:
1. Add migration `supabase/migrations/20260215000003_runtime_contract_fixes.sql`.
2. Set `ops_action_runs.status` default to `'running'` and backfill null/invalid statuses.
3. Add function `get_agents_with_memory_stats()` used by engine heartbeat.
4. Add function `find_corroborated_memories()` used by memory promotion.

Acceptance:
1. Heartbeat insert/update path works without schema errors.
2. Engine RPC calls resolve in local and deployed DB.

## PR4 — Code Contract Fixes (Engine + Frontend)
Implementation:
1. Explicitly set `status: 'running'` on `ops_action_runs` insert in:
   - `packages/frontend/lib/heartbeat-runner.ts`
   - `packages/engine/src/core/heartbeat.ts`
2. Fix `/api/agents` parsing to support canonical shape:
   - `ops_policies['agent_configs'] = { version, startup, agents, conversationFormats, dailySchedule }`
   - Keep temporary fallback for legacy array value.
3. Update typings for policy value shape in frontend route.

Acceptance:
1. Agent list renders from generated policy object.
2. No runtime failure on action run creation.

## PR5 — Generated Seed Compatibility
Implementation:
1. Update step registry insert generation to include required `description` field in:
   - `packages/cli/src/wizard/config-generator.ts`
   - `packages/frontend/app/api/pitch/[sessionId]/generate/route.ts`
2. Add regression tests for SQL generation string content.

Acceptance:
1. Generated seed SQL executes against current schema.
2. No missing-column failures for `ops_step_registry`.

## PR6 — CI and Quality Gates
Implementation:
1. Add repo lint stack (`eslint`, `@typescript-eslint/*`, `eslint-config-next`) and root ESLint config.
2. Add root scripts:
   - `lint`
   - `typecheck`
   - `test`
   - `check` (lint + typecheck + test + build)
3. Add tests with Vitest for:
   - heartbeat cap logic (loop cap, budget cap, no pending steps)
   - pitch state transitions (`in_progress -> synthesis -> approval -> generation -> completed`)
   - control action validation and mode transitions
4. Add `.github/workflows/ci.yml` running `npm ci` + `npm run check`.

Acceptance:
1. CI fails on lint/type/test regressions.
2. Critical-path scenarios are covered and green.

## PR7 — CLI Truthfulness Patch
Implementation:
1. Update `create` and `deploy` command messaging to explicitly mark unsupported paths as not yet implemented.
2. Ensure unsupported deploy subcommands return non-zero exit codes.
3. Remove “Your AI startup is ready to hatch” language unless runnable criteria are met.

Acceptance:
1. CLI no longer implies successful deploy/runtime readiness when not true.
2. Exit codes are automation-safe.

---

## Important Public API / Interface / Type Changes

1. **Security interface**:
   - New required env vars: `HATCHERY_BASIC_AUTH_USER`, `HATCHERY_BASIC_AUTH_PASS`, `CRON_SECRET`.
   - Protected routes now return `401` when unauthorized.

2. **Heartbeat API behavior**:
   - `GET /api/heartbeat` requires bearer token and is cron-only.

3. **Policy schema contract**:
   - Canonical `agent_configs` value is object-shaped with nested `agents` array, not top-level array.

4. **Database interface**:
   - New/updated SQL functions:
     - `get_agents_with_memory_stats()`
     - `find_corroborated_memories()`
   - `ops_action_runs.status` default behavior standardized.

5. **Generated SQL contract**:
   - `ops_step_registry` insert statements include `description`.

---

## Test Cases and Scenarios

1. Unauthorized `GET /api/company/config` returns `401`.
2. Authorized operator can load dashboard, pitch pages, and control actions.
3. Unauthorized `GET /api/heartbeat` returns `401`; valid cron bearer succeeds.
4. Heartbeat run inserts action run with status and completes without schema error.
5. `agent_configs` policy object resolves into `/api/agents` response.
6. Generated seed SQL contains `ops_step_registry (..., description, ...)`.
7. Control actions:
   - invalid action rejected
   - `run_now` blocked when paused/stopped
   - `pause/resume/stop_all` update runtime mode and emit events.
8. Pitch lifecycle guards invalid transitions and allows valid transitions.
9. CI pipeline fails when lint/type/test fails and passes on healthy branch.

---

## Assumptions and Defaults (Locked)

1. Deployment baseline remains `Vercel + Supabase`.
2. Product remains single-tenant during these phases.
3. Internal Alpha access is intentionally operator-gated via Basic Auth.
4. Billing, org multi-tenancy, and full RBAC remain out of scope for these phases.
5. Phase 1 does not add new product features beyond safety/correctness/operability.
6. Activation UX becomes the primary feature focus only in Phase 2.
